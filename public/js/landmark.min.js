class UsefulMethods{constructor(){}
highLowAngle(oldPosition,currentPosition){let maxX=Math.abs(oldPosition.x-currentPosition.x),maxY=Math.abs(oldPosition.y-currentPosition.y);if(Math.max(maxX,maxY)===maxX){return oldPosition.x>currentPosition.x?-1:1}
return oldPosition.y>currentPosition.y?-1:1}
calculateAngle(point_a,point_b){let productModule={first:Math.sqrt(Math.pow(point_a.x,2)+Math.pow(point_a.y,2)),second:Math.sqrt(Math.pow(point_b.x,2)+Math.pow(point_b.y,2))};let scaleProduct=Math.abs(point_a.x*point_b.x+point_a.y*point_b.y);return Math.acos(scaleProduct/(productModule.first*productModule.second))}};class ScaleManager{};class CanvasOdontoradiosis{constructor(stackCanvas){this.stackCanvas=stackCanvas;this.existentCanvas=[];this.pointRadius=4;this.lineWidth=1;this.nameScale=10;this.textRelativePosition={x:15,y:15};let allCanvas=this.stackCanvas.getElementsByTagName("canvas");for(let index=0;index<allCanvas.length;index++){const element=allCanvas[index];this.existentCanvas[element.getAttribute("id")]=element}
this.scaleDrawValue=Object.freeze({pointRadius:4,nameScale:10,lineWidth:2,textRelativePosition:Object.freeze({x:15,y:15})})}
getCanvas(id){return this.existentCanvas[id]}
getContext(id){return this.existentCanvas[id].getContext("2d")}
clearCanvas(canvasId){const canvas=this.getCanvas(canvasId);let context=canvas.getContext("2d");context.canvas.width=context.canvas.width}
drawCircle(context,x,y,pointRadius=this.pointRadius,fillStyle="#184bed",strokeStyle="#184bed"){context.beginPath();context.moveTo(x,y);context.arc(x,y,pointRadius,0,2*Math.PI);context.fillStyle=fillStyle;context.fill();context.lineWidth=this.lineWidth;context.strokeStyle=strokeStyle;context.stroke()}
drawCircleCtx(curveName,x,y,pointRadius=this.pointRadius,fillStyle="#184bed",strokeStyle="#184bed"){this.drawCircle(this.getContext(curveName),x,y,pointRadius,fillStyle,strokeStyle)}
drawBezier(context,x1,y1,cx1,cy1,cx2,cy2,x2,y2,strokeStyle="#00e379"){context.strokeStyle=strokeStyle;context.moveTo(x1,y1);context.bezierCurveTo(cx1,cy1,cx2,cy2,x2,y2);context.lineWidth=this.lineWidth;context.stroke()}
dynamicCanvasScale(valueToResize=1,isX=!1,rect=this.existentCanvas.landmarks.getBoundingClientRect()){const canvasDimensions={width:rect.width,height:rect.height};let context=this.existentCanvas.landmarks.getContext("2d");const imageDimensions={width:context.canvas.width,height:context.canvas.height};if(isX){return((imageDimensions.width*valueToResize)/canvasDimensions.width)}else return((imageDimensions.height*valueToResize)/canvasDimensions.height)}
scaleDraw(canvas){const rect=canvas.getBoundingClientRect();let ctx=canvas.getContext("2d");const imageDimensions={width:ctx.canvas.width,height:ctx.canvas.height};if(imageDimensions.width>imageDimensions.height){this.pointRadius=this.dynamicCanvasScale(this.scaleDrawValue.pointRadius,!0,rect);this.nameScale=this.dynamicCanvasScale(this.scaleDrawValue.nameScale,!0,rect);this.lineWidth=this.dynamicCanvasScale(this.scaleDrawValue.lineWidth,!0,rect);this.textRelativePosition.x=this.dynamicCanvasScale(this.scaleDrawValue.textRelativePosition.x,!0,rect);this.textRelativePosition.y=this.dynamicCanvasScale(this.scaleDrawValue.textRelativePosition.y,!0,rect)}else{this.pointRadius=this.dynamicCanvasScale(this.scaleDrawValue.pointRadius,!1,rect);this.nameScale=this.dynamicCanvasScale(this.scaleDrawValue.nameScale,!1,rect);this.lineWidth=this.dynamicCanvasScale(this.scaleDrawValue.lineWidth,!1,rect);this.textRelativePosition.x=this.dynamicCanvasScale(this.scaleDrawValue.textRelativePosition.x,!1,rect);this.textRelativePosition.y=this.dynamicCanvasScale(this.scaleDrawValue.textRelativePosition.y,!1,rect)}}
getMousePos(canvas=this.existentCanvas.landmarks,event){const rect=canvas.getBoundingClientRect();return{x:this.dynamicCanvasScale(event.clientX-rect.left,!0,rect),y:this.dynamicCanvasScale(event.clientY-rect.top,!1,rect)}}
openImage(path="",loadFunction=null){let imageObject=new Image();if(this.existentCanvas.image.getContext){const context=this.existentCanvas.image.getContext("2d");const self=this;imageObject.onload=function(){context.canvas.width=this.width;context.canvas.height=this.height;["landmarks","bezier"].forEach(element=>{const temporaryContext=self.existentCanvas[element].getContext("2d");temporaryContext.canvas.width=context.canvas.width;temporaryContext.canvas.height=context.canvas.height});const cardCanvas=document.getElementById("card-canvas");if(cardCanvas){cardCanvas.setAttribute("style","height: "+context.canvas.height+"px")}
self.scaleDraw.call(self,self.existentCanvas.landmarks);context.drawImage(imageObject,0,0,context.canvas.width,context.canvas.height);context.fillStyle="rgba(1, 1, 1, 0)";if(loadFunction){loadFunction()}}}
imageObject.src=path}};class AnatomicalTracing{constructor(canvas,lineWidth){this.canvas=canvas;this.lineWidth=lineWidth!=null?lineWidth:canvas.lineWidth;this.allCurves=[];this.currentBoxPoints=[0,0,0,0]}
setAllCurves(curves){this.allCurves=curves}
getBoxPoints(curveName,recalculate){if(this.currentBoxPoints!=null&&recalculate!==!0){return this.currentBoxPoints}
let minX=Number.POSITIVE_INFINITY,minY=Number.POSITIVE_INFINITY;let maxX=Number.NEGATIVE_INFINITY,maxY=Number.NEGATIVE_INFINITY;this.allCurves[curveName].forEach(function(element,index,array){element.forEach(function(point,position,arr){if(position%2!==0){minY=Math.min(minY,point);maxY=Math.max(maxY,point)}else{minX=Math.min(minX,point);maxX=Math.max(maxX,point)}})});this.currentBoxPoints=[minX,minY,maxX,maxY];return this.currentBoxPoints}
getBoxDimensions(curveName,borderSize,recalculate){if(borderSize==null){borderSize=20}
let points=getBoxPoints(curveName,recalculate);let minX=points[0],minY=points[1];let maxX=points[2],maxY=points[3];let width=maxX-minX,height=maxY-minY;return[minX-borderSize,minY-borderSize,width+borderSize*2,height+borderSize*2]}
verifyMouseOnBoxVertex(relativeMouse,curveName){const boxVertex=this.getBoxDimensions(curveName,null,!0);let isOn=!1;let vertexIndex=0;[[boxVertex[0],boxVertex[1]],[boxVertex[0],boxVertex[1]+boxVertex[3]],[boxVertex[0]+boxVertex[2],boxVertex[1]],[boxVertex[0]+boxVertex[2],boxVertex[1]+boxVertex[3]]].forEach(function(element,index,array){if(relativeMouse.x>=element[0]-pointRadius&&relativeMouse.x<=element[0]+pointRadius&&relativeMouse.y>=element[1]-pointRadius&&relativeMouse.y<=element[1]+pointRadius){isOn=!0;vertexIndex=index}});return{isOn:isOn,index:vertexIndex}}
verifyMouseOnCurvePoint(relativeMouse,curveName){let isOn=null;allCurves[curveName].forEach(function(element,index,array){element.forEach(function(point,position,arr){if(position%2===0){if(relativeMouse.x>=element[position]-pointRadius&&relativeMouse.x<=element[position]+pointRadius&&relativeMouse.y>=element[position+1]-pointRadius&&relativeMouse.y<=element[position+1]+pointRadius){isOn=[element,position,position+1]}}})});return isOn}
drawAllCurves(){this.canvas.clearCanvas("bezier");const selfCanvas=this.canvas;const selfCurves=this.allCurves;Object.keys(this.allCurves).forEach(function(element,index,_array){selfCurves[element].forEach(function(points,position,arr){if(position===0){selfCanvas.drawBezier.call(selfCanvas,selfCanvas.getContext.call(selfCanvas,"bezier"),points[0],points[1],points[2],points[3],points[4],points[5],points[6],points[7],"#00e379")}else{let temporary=selfCurves[element][position-1];selfCanvas.drawBezier.call(selfCanvas,selfCanvas.getContext.call(selfCanvas,"bezier"),temporary[temporary.length-2],temporary[temporary.length-1],points[0],points[1],points[2],points[3],points[4],points[5],"#00e379")}})})}
drawPointCircle(curveName){curveName=curveName.replace(/ /g,"-").toLowerCase();if(this.allCurves[curveName]!=null){const context=this.canvas.getContext("bezier");this.allCurves[curveName].forEach(function(element,index,array){element.forEach(function(point,position,arr){if(position%2!==0){drawCircle(context,element[position-1],element[position])}})})}}
drawBoxVertex(context){[[curveBox[0],curveBox[1]],[curveBox[0],curveBox[1]+curveBox[3]],[curveBox[0]+curveBox[2],curveBox[1]],[curveBox[0]+curveBox[2],curveBox[1]+curveBox[3]]].forEach(function(element,index,array){this.canvas.drawCircle(context,element[0],element[1])})}
drawCurveBox(currentCurve,recalculate){if(currentCurve!=null){currentCurve=currentCurve.replace(/ /g,"-").toLowerCase();this.drawAllCurves();if(this.allCurves[currentCurve]!=null){const curveBox=this.getBoxDimensions(currentCurve,null,recalculate);let context=this.canvas.getCanvas("bezier").getContext("2d");context.lineWidth=lineWidth;context.beginPath();context.rect(curveBox[0],curveBox[1],curveBox[2],curveBox[3]);context.stroke();this.drawBoxVertex(context)}}}
runPointsAndChange(curveName,callback_1,callback_2,recalculate){if(this.allCurves[curveName]!=null){this.allCurves[curveName].forEach(function(points,index,array){points.forEach(function(point,position,arr){if(position%2===0){points[position]=callback_1(points[position],points[position+1])}else{points[position]=callback_2(points[position],points[position-1])}})});this.drawCurveBox(curveName,recalculate)}}
translateBezier(curveName,amountX,amountY){curveName=curveName.replace(/ /g,"-").toLowerCase();boxPoints[0]-=amountX;boxPoints[1]-=amountY;boxPoints[2]-=amountX;boxPoints[3]-=amountY;this.runPointsAndChange(curveName,function(pointX){return pointX-amountX},function(pointY){return pointY-amountY},!0)}
rotateBezier(curveName,angle){curveName=curveName.replace(/ /g,"-").toLowerCase();this.runPointsAndChange(curveName,function(pointX,pointY){return pointX*Math.cos(angle)-pointY*Math.sin(angle)},function(pointY,pointX){return pointX*Math.sin(angle)+pointY*Math.cos(angle)},!0)}
rescaleBezier(curveName,scaleX,scaleY){curveName=curveName.replace(/ /g,"-").toLowerCase();this.runPointsAndChange(curveName,function(pointX){return pointX*scaleX},function(pointY){return pointY*scaleY},!0)}};class ImageEffects{constructor(canvas){this.brightness=document.getElementById("brightness");this.contrast=document.getElementById("contrast");this.grayscale=document.getElementById("grayscale");this.invert=document.getElementById("invert");this.canvasManager=canvas}
getValues(){let filterStyle="filter: ",brightnessValue=this.brightness.value,contrastValue=this.contrast.value,grayscaleValue=this.grayscale.value,invertValue=this.invert.value;filterStyle+=`
            brightness(${brightnessValue}%)
            contrast(${contrastValue}%)
            grayscale(${grayscaleValue}%)
            invert(${invertValue}%)`;return filterStyle}
onChangeValue(){const imageElement=this.canvasManager.getCanvas("image");let filterValue=this.getValues();imageElement.setAttribute("style",filterValue)}
reset(){this.brightness.value=100;this.contrast.value=100;this.grayscale.value=0;this.invert.value=0;this.onChangeValue()}};class TracingController{constructor(canvasOdontoradiosis){this.canvasOdontoradiosis=canvasOdontoradiosis;this.anatomicalTracing=new AnatomicalTracing(canvasOdontoradiosis,null);this.bezierPoints=[]}
setBezierPoints(points){this.bezierPoints=points;this.anatomicalTracing.setAllCurves(points)}
toJson(toConvertArray){let returnedJson="{";Object.keys(toConvertArray).forEach(function(element,index,array){if(index>0){returnedJson+=","}
returnedJson+='"'+element+'":[';toConvertArray[element].forEach(function(subElement,position,arr){if(position>0){returnedJson+=","}
returnedJson+="[";subElement.forEach(function(item,count,subArray){if(count>0){returnedJson+=","}
returnedJson+=item});returnedJson+="]"});returnedJson+="]"});returnedJson+="}";return returnedJson}
saveBezierCurve(){const curvesJson=this.toJson(this.bezierPoints);let hiddenForm=document.getElementById("bezier_curves");hiddenForm.setAttribute("value",curvesJson)}
drawAllCurves(){this.anatomicalTracing.drawAllCurves();this.saveBezierCurve()}
drawCurveBox(currentCurve){this.anatomicalTracing.drawCurveBox(currentCurve,!1)}
drawPointCircle(curveName){this.anatomicalTracing.drawPointCircle(curveName)}};class LandmarksController{constructor(canvasOdontoradiosis){this.landmarks=[];this.canvas=canvasOdontoradiosis}
setLandmarks(newLandmarks){this.landmarks=newLandmarks}
landmarksToJSON(js_array){let returned_json="{";for(let key in js_array){if(returned_json.length>1){returned_json=returned_json+","}
returned_json=returned_json+'"'+key+'":{';let internalArray=js_array[key];returned_json=returned_json+'"X":'+internalArray.X+',"Y":'+internalArray.Y+"}"}
returned_json=returned_json+"}";return returned_json}
saveLandmarks(landmarks){const data_json=this.landmarksToJSON(landmarks);let hiddenForm=document.getElementById("saved_points");hiddenForm.setAttribute("value",data_json)}
drawLandmark(canvasContext,landmarkName){const locations=this.landmarks[landmarkName];const context=canvasContext;context.beginPath();context.arc(locations.X,locations.Y,this.canvas.pointRadius,0,2*Math.PI);context.fillStyle="red";context.font=this.canvas.nameScale+"px Arial";context.fillText(landmarkName.match(/\(.+\)/),Math.floor(parseInt(locations.X)-this.canvas.textRelativePosition.x),Math.floor(parseInt(locations.Y)+this.canvas.textRelativePosition.y));context.fill();context.lineWidth=1;context.strokeStyle="#330005";context.stroke()}
redrawLandmarks(){const landmarksCanvas=this.canvas.getCanvas("landmark");const context=landmarksCanvas.getContext("2d");context.clearRect(0,0,canvas.width,canvas.height);Object.keys(this.landmarks).forEach(function(element,index,array){this.drawLandmark(context,element)})}};class MainController{constructor(urls,canvasOdontoradiosis){this.urls=urls;this.tracingController=new TracingController(canvasOdontoradiosis);this.landmarksController=new LandmarksController(canvasOdontoradiosis)}
getUrl(id){return this.urls[id]}
setUrl(id,address){this.urls[id]=address}
loadJsonLandmarks(id){if(id&&id>0){const landmarkJson=this.urls.landmarks.replace("%REPLACE%",id);const selfLandmarksController=this.landmarksController;fetch(landmarkJson).then(response=>{return response.json()}).then(data=>{selfLandmarksController.setLandmarks.call(selfLandmarksController,data)}).then(()=>{selfLandmarksController.redrawLandmarks.call(selfLandmarksController)})}}
loadJsonCurve(id){if(id&&id>0){const curveJson=this.urls.curves.replace("%REPLACE%",id);const selfTracingController=this.tracingController;selfTracingController.drawAllCurves.call(selfTracingController);fetch(curveJson).then(response=>{return response.json()}).then(data=>{selfTracingController.setBezierPoints.call(selfTracingController,data)}).then(()=>{selfTracingController.drawAllCurves.call(selfTracingController)})}}
referenceLandmarks(){const selectedIndex=document.getElementById("pointsId").selectedIndex;const currentPoint=document.getElementById("pointsId").options[selectedIndex].text;const imagePaths=[];imagePaths["Sela (S)"]="selaTurcica.png";imagePaths["Násio (N)"]="nasio.png";imagePaths["Espinha nasal anterior (ENA)"]="ENA.png";imagePaths["Espinha nasal posterior (ENP)"]="ENP.png";imagePaths["Ponto subespinhal (A)"]="A.png";imagePaths["Ponto pupramental (B)"]="B.png";imagePaths["Pogônio (Pog)"]="pogonio.png";imagePaths["Gnátio (Gn)"]="Gnatio.png";imagePaths["Mento (Me)"]="mento.png";imagePaths["Condílio (Co)"]="condilio.png";imagePaths["Pró-nasal (Pn)"]="proNasal.png";imagePaths["Pogônio Mole (Pg)"]="pogonioMole.png";imagePaths["Palato Mole (pm)"]="palatoMole.png";imagePaths["Gônio (Go)"]="";imagePaths["Órbitário (Or)"]="";imagePaths["Pório (Po)"]="";imagePaths["Ponta do Nariz (PtN)"]="";imagePaths["Fossa Ptérigo Maxilar (Fpm)"]="";imagePaths["Pterigóide (Pt)"]="";if(currentPoint!=="Selecione"&&imagePaths[currentPoint]){let img=new Image();let context=document.getElementById("referenceLandmark");if(context.getContext){context=context.getContext("2d");img.onload=function(){context.canvas.width=this.width;context.canvas.height=this.height;document.getElementById("canvas-reference").setAttribute("style","height: "+context.canvas.height+"px"+"width: "+context.canvas.width+"px");context.drawImage(img,0,0,context.canvas.width,context.canvas.height);context.fillStyle="rgba(1, 1, 1, 0)"}}
img.src=this.urls.reference_images+imagePaths[currentPoint]}}
coordinates(event){const selectedIndex=document.getElementById("pointsId").selectedIndex;const currentPoint=document.getElementById("pointsId").options[selectedIndex].text;if(currentPoint!=="Selecione"){x=event.pageX;y=event.pageY;const div=document.getElementById("landmarks");if(!global_points[currentPoint]){global_points[currentPoint]=[]}
const currentMousePosition=getMousePos(div,event);global_points[currentPoint].X=currentMousePosition.x;global_points[currentPoint].Y=currentMousePosition.y;redrawLandmark(div);saveLandmarks(global_points)}}
bezier_functions(event){event.preventDefault();event.stopPropagation();const canvas=document.getElementById("bezier");let context=canvas.getContext("2d");context.translate(canvas.width/2,canvas.height/2);if(isMouseDown&&isCurveFunction){document.getElementById("bezier").style.cursor="move";const selectedIndex=document.getElementById("curvesId").selectedIndex;const curveName=document.getElementById("curvesId").options[selectedIndex].text;if(mousePosition.x==null){mousePosition.x=dynamicCanvasScale(event.clientX,!0);mousePosition.y=dynamicCanvasScale(event.clientY,!1)}else{let currentPosition={x:dynamicCanvasScale(event.clientX,!0),y:dynamicCanvasScale(event.clientY,!1)};saveBezierCurve();if(isOnBoxVertex.isOn){let scaleX=currentPosition.x/mousePosition.x;if(isOnBoxVertex.index<2){scaleX=mousePosition.x/currentPosition.x}
let scaleY=currentPosition.y/mousePosition.y;if(isOnBoxVertex.index%2===0){scaleY=mousePosition.y/currentPosition.y}
rescaleBezier(curveName,scaleX,scaleY)}else if(isOnCurvePoints!=null){isOnCurvePoints[0][isOnCurvePoints[1]]-=mousePosition.x-currentPosition.x;isOnCurvePoints[0][isOnCurvePoints[2]]-=mousePosition.y-currentPosition.y;bezier_curve(curveName,!0)}else if(isInsideBox){translateBezier(curveName,mousePosition.x-currentPosition.x,mousePosition.y-currentPosition.y)}else{let angle=calculateAngle(currentPosition,mousePosition);if(!isNaN(angle)){angle*=highLowAngle(mousePosition,{x:currentPosition.x,y:currentPosition.y});rotateBezier(curveName,angle)}}
mousePosition.x=currentPosition.x;mousePosition.y=currentPosition.y;drawPointCircle(curveName)}}else if(isCurveFunction){document.getElementById("bezier").style.cursor="crosshair"}}
bezier_coordinate(event){const selectedIndex=document.getElementById("curvesId").selectedIndex;const currentCurve=document.getElementById("curvesId").options[selectedIndex].text;const curveName=currentCurve.replace(/ /g,"-").toLowerCase();if(currentCurve==="Selecione"){isCurveFunction=!1;coordinates(event)}else if(all_curves[curveName]!=null){isCurveFunction=!0;let points=getBoxDimensions(curveName);const relativeMouse=getMousePos(document.getElementById("bezier"),event);isInsideBox=relativeMouse.x>=points[0]&&relativeMouse.x<=points[0]+points[2]&&relativeMouse.y>=points[1]&&relativeMouse.y<=points[1]+points[3];isOnBoxVertex=verifyMouseOnBoxVertex(relativeMouse,curveName);isOnCurvePoints=verifyMouseOnCurvePoint(relativeMouse,curveName)}}
facial_analysis(){if(enable_draw_bezier){const glabela={x:all_curves["perfil-mole"][0][0],y:all_curves["perfil-mole"][0][1]};const subnasal={x:all_curves["perfil-mole"][1][4],y:all_curves["perfil-mole"][1][5]};const pogonion={x:all_curves["perfil-mole"][5][4],y:all_curves["perfil-mole"][5][5]};const div=document.getElementById("bezier");let ctx=div.getContext("2d");ctx.strokeStyle="#451c87";ctx.beginPath();ctx.moveTo(pogonion.x,pogonion.y);ctx.lineTo(subnasal.x,subnasal.y);ctx.lineTo(glabela.x,glabela.y);ctx.lineWidth=lineWidth*2;ctx.stroke();let toCalculate=normalizeValues(glabela,pogonion,subnasal);let angle=calculateAngle(toCalculate[0],toCalculate[1])*(subnasal.x>pogonion.x?-1:1);angle=(180*angle)/Math.PI;let td=document.getElementById("td-face_type");if(angle+5>=0&&angle+5<=10){td.innerHTML="Reto"}else if(angle<0){td.innerHTML="Concavo"}else{td.innerHTML="Convexo"}}}};class EventsOdontoradiosis{constructor(mainController,imageEffects){this.mainController=mainController;this.imageEffects=imageEffects;this.isMouseDown=!1;this.isInsideBox=!1;this.isOnBoxVertex={isOn:!1,index:0};this.isOnCurvePoints=null;this.mousePosition={x:null,y:null};document.getElementById("stack-canvas").setAttribute("onmousedown","bezier_coordinate(event)");document.getElementById("stack-canvas").setAttribute("onmousemove","bezier_functions(event)")}
addEffectsEvent(){let elements=["contrast","brightness","invert","grayscale"];const selfImageEffects=this.imageEffects;for(let i=0;i<elements.length;i++){document.getElementById(elements[i]).addEventListener("input",function(){selfImageEffects.onChangeValue.call(selfImageEffects)})}
document.getElementById("undone-effects").onclick=function(){selfImageEffects.reset.call(selfImageEffects)}}
addCanvasEvents(){let curveSelect=document.getElementById("curvesId");const tracingController=this.mainController.tracingController;curveSelect.addEventListener("input",function(){const selectedIndex=document.getElementById("curvesId").selectedIndex;const currentCurve=document.getElementById("curvesId").options[selectedIndex].text;tracingController.drawCurveBox.call(tracingController,currentCurve);tracingController.drawPointCircle.call(tracingController,currentCurve);if(currentCurve!=="Selecione"){document.getElementById("stack-canvas").style.cursor="move"}else{document.getElementById("stack-canvas").style.cursor="crosshair"}})}
generateMouseEvents(){const currentObject=this;document.onmousedown=function(){let hiddenForm=document.getElementById("current_image");const splicedSource=currentObject.mainController.getUrl("image").split("/");hiddenForm.setAttribute("value",splicedSource[splicedSource.length-2]+"/"+splicedSource[splicedSource.length-1]);currentObject.isMouseDown=!0};document.onmouseup=function(){currentObject.isMouseDown=!1;currentObject.isInsideBox=!1;currentObject.isOnBoxVertex={isOn:!1,index:0};currentObject.isOnCurvePoints=null;currentObject.mousePosition.x=null;currentObject.mousePosition.y=null}}
applyAllEvents(){this.addEffectsEvent();this.addCanvasEvents();this.generateMouseEvents()}};const canvasOdontoradiosis=new CanvasOdontoradiosis(document.getElementById("stack-canvas"));const imageEffects=new ImageEffects(canvasOdontoradiosis);const mainController=new MainController({image:"",curves:curves_url,landmarks:landmarks_url,reference_images:reference_images_url},canvasOdontoradiosis);const eventsController=new EventsOdontoradiosis(mainController,imageEffects);function openImage(path="",id=-1){mainController.tracingController.setBezierPoints([]);mainController.setUrl("image",path);canvasOdontoradiosis.openImage(path,function(){mainController.loadJsonCurve(id);mainController.loadJsonLandmarks(id)},id);imageEffects.reset()}
window.onload=function(){eventsController.applyAllEvents()}