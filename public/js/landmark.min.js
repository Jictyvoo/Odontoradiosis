class OdontoradiosisKeeper{constructor(){this.isMouseDown=!1;this.isInsideBox=!1;this.isOnBoxVertex={isOn:!1,index:0};this.isOnCurvePoints=null;this.mousePosition={x:null,y:null};this.isCurveFunction=!1}};class UsefulMethods{static canvasStyle(z_index=0,position="absolute",left=0,top=0){return `position: ${position}; left: ${left}; top: ${top}; z-index: ${z_index};`}
static normalizeTracingName(toNormalize){return toNormalize.replace(/ /g,"-").toLowerCase()}
static highLowAngle(oldPosition,currentPosition){let maxX=Math.abs(oldPosition.x-currentPosition.x),maxY=Math.abs(oldPosition.y-currentPosition.y);if(Math.max(maxX,maxY)===maxX){return oldPosition.x>currentPosition.x?-1:1}
return oldPosition.y>currentPosition.y?-1:1}
normalizeValues(point_a,point_b,origin){let normalized=[{x:point_a.x,y:point_a.y},{x:point_b.x,y:point_b.y}];normalized[0].x-=origin.x;normalized[0].y-=origin.y;normalized[1].x-=origin.x;normalized[1].y-=origin.y;return normalized}
static calculateAngle(point_a,point_b){let productModule={first:Math.sqrt(Math.pow(point_a.x,2)+Math.pow(point_a.y,2)),second:Math.sqrt(Math.pow(point_b.x,2)+Math.pow(point_b.y,2))};let scaleProduct=Math.abs(point_a.x*point_b.x+point_a.y*point_b.y);return Math.acos(scaleProduct/(productModule.first*productModule.second))}};class ScaleManager{constructor(){this.pointRadius=4;this.lineWidth=1;this.nameScale=10;this.textRelativePosition={x:15,y:15};this.scaleDrawValue=Object.freeze({pointRadius:4,nameScale:10,lineWidth:2,textRelativePosition:Object.freeze({x:15,y:15})})}
dynamicCanvasScale(valueToResize=1,isX=!1,context,clientRect){const canvasDimensions={width:clientRect.width,height:clientRect.height};const imageDimensions={width:context.canvas.width,height:context.canvas.height};if(isX){return((imageDimensions.width*valueToResize)/canvasDimensions.width)}else return((imageDimensions.height*valueToResize)/canvasDimensions.height)}
calculateScales(canvas){const rect=canvas.getBoundingClientRect();const context=canvas.getContext("2d");const imageDimensions={width:context.canvas.width,height:context.canvas.height};const isX=imageDimensions.width>imageDimensions.height;this.pointRadius=this.dynamicCanvasScale(this.scaleDrawValue.pointRadius,isX,context,rect);this.nameScale=this.dynamicCanvasScale(this.scaleDrawValue.nameScale,isX,context,rect);this.lineWidth=this.dynamicCanvasScale(this.scaleDrawValue.lineWidth,isX,context,rect);this.textRelativePosition.x=this.dynamicCanvasScale(this.scaleDrawValue.textRelativePosition.x,isX,context,rect);this.textRelativePosition.y=this.dynamicCanvasScale(this.scaleDrawValue.textRelativePosition.y,isX,context,rect)}
getMousePos(canvas,event){const rect=canvas.getBoundingClientRect();const context=canvas.getContext("2d");return{x:this.dynamicCanvasScale(event.clientX-rect.left,!0,context,rect),y:this.dynamicCanvasScale(event.clientY-rect.top,!1,context,rect)}}};class CanvasOdontoradiosis{constructor(stackCanvas,scaleManager,layerSequence=[]){this.stackCanvas=stackCanvas;this.layerSequence=layerSequence;this.existentCanvas=[];this.scaleManager=scaleManager;let allCanvas=this.stackCanvas.getElementsByTagName("canvas");for(let index=0;index<allCanvas.length;index++){const element=allCanvas[index];const canvasName=element.getAttribute("id");this.existentCanvas[canvasName]=element;element.setAttribute("style",UsefulMethods.canvasStyle(layerSequence[canvasName]))}}
getCanvas(id){return this.existentCanvas[id]}
getContext(id){return this.existentCanvas[id].getContext("2d")}
setStyle(id,styleName,newStyle){this.getCanvas(id).style[styleName]=newStyle}
clearCanvas(canvasId){const canvas=this.getCanvas(canvasId);let context=canvas.getContext("2d");context.canvas.width=context.canvas.width}
drawCircle(context,x=0,y=0,pointRadius=this.scaleManager.pointRadius,lineWidth=this.scaleManager.lineWidth,fillStyle="#184bed",strokeStyle="#184bed"){context.beginPath();context.arc(x,y,pointRadius,0,2*Math.PI);context.fillStyle=fillStyle;context.fill();context.lineWidth=lineWidth;context.strokeStyle=strokeStyle;context.stroke()}
drawCircleCtx(layerId,x=0,y=0,pointRadius=this.scaleManager.pointRadius,lineWidth=this.scaleManager.lineWidth,fillStyle="#184bed",strokeStyle="#184bed"){this.drawCircle(this.getContext(layerId),x,y,pointRadius,lineWidth,fillStyle,strokeStyle)}
drawBezier(context,x1,y1,cx1,cy1,cx2,cy2,x2,y2,strokeStyle="#00e379"){context.strokeStyle=strokeStyle;context.moveTo(x1,y1);context.bezierCurveTo(cx1,cy1,cx2,cy2,x2,y2);context.lineWidth=this.scaleManager.lineWidth;context.stroke()}
openImage(path="",loadFunction=null){let imageObject=new Image();if(this.existentCanvas.image.getContext){const context=this.existentCanvas.image.getContext("2d");const self=this;const selfScaleManager=this.scaleManager;imageObject.onload=function(){context.canvas.width=this.width;context.canvas.height=this.height;["landmarks","bezier"].forEach(element=>{const temporaryContext=self.existentCanvas[element].getContext("2d");temporaryContext.canvas.width=context.canvas.width;temporaryContext.canvas.height=context.canvas.height});const cardCanvas=document.getElementById("card-canvas");if(cardCanvas){cardCanvas.setAttribute("style","height: "+context.canvas.height+"px")}
selfScaleManager.calculateScales.call(selfScaleManager,self.existentCanvas.landmarks);context.drawImage(imageObject,0,0,context.canvas.width,context.canvas.height);context.fillStyle="rgba(1, 1, 1, 0)";if(loadFunction){loadFunction()}}}
imageObject.src=path}};class AnatomicalTracing{constructor(canvas){this.canvas=canvas;this.allCurves=[]}
setAllCurves(curves){this.allCurves=curves}
drawAllCurves(){this.canvas.clearCanvas("bezier");const selfCanvas=this.canvas;const selfCurves=this.allCurves;Object.keys(this.allCurves).forEach(function(element,index,_array){selfCurves[element].forEach(function(points,position,arr){if(position===0){selfCanvas.drawBezier.call(selfCanvas,selfCanvas.getContext.call(selfCanvas,"bezier"),points[0],points[1],points[2],points[3],points[4],points[5],points[6],points[7],"#00e379")}else{let temporary=selfCurves[element][position-1];selfCanvas.drawBezier.call(selfCanvas,selfCanvas.getContext.call(selfCanvas,"bezier"),temporary[temporary.length-2],temporary[temporary.length-1],points[0],points[1],points[2],points[3],points[4],points[5],"#00e379")}})})}
drawPointCircle(curveName){if(this.allCurves[curveName]!=null){const context=this.canvas.getContext("bezier");for(let index=0;index<this.allCurves[curveName].length;index++){const element=this.allCurves[curveName][index];for(let subindex=1;subindex<element.length;subindex+=2){this.canvas.drawCircle(context,element[subindex-1],element[subindex])}}}}
drawBoxVertex(context,boxDimensions){const selfCanvas=this.canvas;[[boxDimensions[0],boxDimensions[1]],[boxDimensions[0],boxDimensions[1]+boxDimensions[3]],[boxDimensions[0]+boxDimensions[2],boxDimensions[1]],[boxDimensions[0]+boxDimensions[2],boxDimensions[1]+boxDimensions[3]]].forEach(function(element,index,array){selfCanvas.drawCircle.call(selfCanvas,context,element[0],element[1])})}
drawCurveBox(currentCurve,boxDimensions){if(currentCurve!=null){let context=this.canvas.getContext("bezier");context.beginPath();context.lineWidth=this.canvas.scaleManager.lineWidth;context.rect(boxDimensions[0],boxDimensions[1],boxDimensions[2],boxDimensions[3]);context.stroke();this.drawBoxVertex(context,boxDimensions)}}};class ImageEffects{constructor(canvas){this.brightness=document.getElementById("brightness");this.contrast=document.getElementById("contrast");this.grayscale=document.getElementById("grayscale");this.invert=document.getElementById("invert");this.canvasManager=canvas}
getValues(){const brightnessValue=this.brightness.value,contrastValue=this.contrast.value,grayscaleValue=this.grayscale.value,invertValue=this.invert.value;const filterStyle=`brightness(${brightnessValue}%) contrast(${contrastValue}%) grayscale(${grayscaleValue}%) invert(${invertValue}%)`;return filterStyle}
onChangeValue(){let filterValue=this.getValues();this.canvasManager.setStyle("image","filter",filterValue)}
reset(){this.brightness.value=100;this.contrast.value=100;this.grayscale.value=0;this.invert.value=0;this.onChangeValue()}};class TracingController{constructor(canvasOdontoradiosis){this.canvasOdontoradiosis=canvasOdontoradiosis;this.anatomicalTracing=new AnatomicalTracing(canvasOdontoradiosis);this.bezierPoints=[];this.currentBoxPoints=[0,0,0,0]}
setBezierPoints(points){this.bezierPoints=points;this.anatomicalTracing.setAllCurves(points)}
curveExists(curveId=""){return this.bezierPoints[curveId]!=null}
saveBezierCurve(){const curvesJson=JSON.stringify(this.bezierPoints);let hiddenForm=document.getElementById("bezier_curves");hiddenForm.setAttribute("value",curvesJson)}
getBoxPoints(curveName,recalculate){if(this.currentBoxPoints!=null&&!recalculate){return this.currentBoxPoints}
let minX=Number.POSITIVE_INFINITY,minY=Number.POSITIVE_INFINITY;let maxX=Number.NEGATIVE_INFINITY,maxY=Number.NEGATIVE_INFINITY;this.bezierPoints[curveName].forEach(function(element,index,array){element.forEach(function(point,position,arr){if(position%2!==0){minY=Math.min(minY,point);maxY=Math.max(maxY,point)}else{minX=Math.min(minX,point);maxX=Math.max(maxX,point)}})});this.currentBoxPoints=[minX,minY,maxX,maxY];return this.currentBoxPoints}
getBoxDimensions(curveName,borderSize=20,recalculate=!1){const points=this.getBoxPoints(curveName,recalculate);let minX=points[0],minY=points[1];let maxX=points[2],maxY=points[3];let width=maxX-minX,height=maxY-minY;return[minX-borderSize,minY-borderSize,width+borderSize*2,height+borderSize*2]}
drawAllCurves(){this.anatomicalTracing.drawAllCurves();this.saveBezierCurve()}
drawCurveBox(currentCurve,recalculate){this.anatomicalTracing.drawCurveBox(currentCurve,this.getBoxDimensions(currentCurve,null,recalculate))}
drawPointCircle(curveName){this.anatomicalTracing.drawPointCircle(curveName)}
verifyMouseOnBoxVertex(relativeMouse,curveName){const boxVertex=this.getBoxDimensions(curveName,null,!0);let isOn=!1;let vertexIndex=0;const pointRadius=this.canvasOdontoradiosis.scaleManager.pointRadius;[[boxVertex[0],boxVertex[1]],[boxVertex[0],boxVertex[1]+boxVertex[3]],[boxVertex[0]+boxVertex[2],boxVertex[1]],[boxVertex[0]+boxVertex[2],boxVertex[1]+boxVertex[3]]].forEach(function(element,index,array){if(relativeMouse.x>=element[0]-pointRadius&&relativeMouse.x<=element[0]+pointRadius&&relativeMouse.y>=element[1]-pointRadius&&relativeMouse.y<=element[1]+pointRadius){isOn=!0;vertexIndex=index}});return{isOn:isOn,index:vertexIndex}}
verifyMouseOnCurvePoint(relativeMouse,curveName){let isOn=null;const pointRadius=this.canvasOdontoradiosis.scaleManager.pointRadius;for(let index=0;index<this.bezierPoints[curveName].length;index++){const element=this.bezierPoints[curveName][index];for(let subindex=0;subindex<element.length;subindex+=2){if(relativeMouse.x>=element[subindex]-pointRadius&&relativeMouse.x<=element[subindex]+pointRadius&&relativeMouse.y>=element[subindex+1]-pointRadius&&relativeMouse.y<=element[subindex+1]+pointRadius){isOn=[element,subindex,subindex+1]}}}
return isOn}
runPointsAndChange(curveName,callback_1,callback_2,recalculate){if(this.bezierPoints[curveName]!=null){this.bezierPoints[curveName].forEach(function(points,index,array){points.forEach(function(point,position,arr){if(position%2===0){points[position]=callback_1(points[position],points[position+1])}else{points[position]=callback_2(points[position],points[position-1])}})})}}
translateBezier(curveName,amountX,amountY){this.currentBoxPoints[0]-=amountX;this.currentBoxPoints[1]-=amountY;this.currentBoxPoints[2]-=amountX;this.currentBoxPoints[3]-=amountY;this.runPointsAndChange(curveName,function(pointX){return pointX-amountX},function(pointY){return pointY-amountY},!0)}
rotateBezier(curveName,angle){this.runPointsAndChange(curveName,function(pointX,pointY){return pointX*Math.cos(angle)-pointY*Math.sin(angle)},function(pointY,pointX){return pointX*Math.sin(angle)+pointY*Math.cos(angle)},!0)}
rescaleBezier(curveName,scaleX,scaleY){this.runPointsAndChange(curveName,function(pointX){return pointX*scaleX},function(pointY){return pointY*scaleY},!0)}};class LandmarksController{constructor(canvasOdontoradiosis){this.landmarks=[];this.canvas=canvasOdontoradiosis}
getLandmarks(){return this.landmarks}
setLandmarks(newLandmarks){this.landmarks=newLandmarks}
verifyLandmark(name,toCreate=!1){if(!this.landmarks[name]&&toCreate){this.landmarks[name]=[]}
return this.landmarks[name]}
saveLandmarks(){const data_json=JSON.stringify(this.landmarks);let hiddenForm=document.getElementById("saved_points");hiddenForm.setAttribute("value",data_json)}
drawLandmark(canvasContext,landmarkName){const locations=this.landmarks[landmarkName];const context=canvasContext;this.canvas.drawCircleCtx("landmarks",locations.X,locations.Y,this.canvas.scaleManager.pointRadius,1,"red","#330005");context.beginPath();context.fillStyle="red";context.font=this.canvas.scaleManager.nameScale+"px Arial";context.fillText(landmarkName.match(/\(.+\)/),Math.floor(parseInt(locations.X)-this.canvas.scaleManager.textRelativePosition.x),Math.floor(parseInt(locations.Y)+this.canvas.scaleManager.textRelativePosition.y));context.fill();context.lineWidth=1;context.strokeStyle="#330005";context.stroke()}
redrawLandmarks(){const landmarksCanvas=this.canvas.getCanvas("landmarks");const context=landmarksCanvas.getContext("2d");context.clearRect(0,0,landmarksCanvas.width,landmarksCanvas.height);const self=this;Object.keys(this.landmarks).forEach(function(element,index,array){self.drawLandmark.call(self,context,element)})}};class MainController{constructor(urls,canvasOdontoradiosis,scaleManager,infoKeeper){this.urls=urls;this.canvasOdontoradiosis=canvasOdontoradiosis;this.scaleManager=scaleManager;this.tracingController=new TracingController(canvasOdontoradiosis);this.landmarksController=new LandmarksController(canvasOdontoradiosis);this.infoKeeper=infoKeeper}
getUrl(id){return this.urls[id]}
setUrl(id,address){this.urls[id]=address}
loadJsonLandmarks(id){if(id&&id>0){const landmarkJson=this.urls.landmarks.replace("%REPLACE%",id);const selfLandmarksController=this.landmarksController;fetch(landmarkJson).then(response=>{return response.json()}).then(data=>{selfLandmarksController.setLandmarks.call(selfLandmarksController,data)}).then(()=>{selfLandmarksController.redrawLandmarks.call(selfLandmarksController)})}}
loadJsonCurve(id){if(id&&id>0){const curveJson=this.urls.curves.replace("%REPLACE%",id);const selfTracingController=this.tracingController;selfTracingController.drawAllCurves.call(selfTracingController);fetch(curveJson).then(response=>{return response.json()}).then(data=>{selfTracingController.setBezierPoints.call(selfTracingController,data)}).then(()=>{selfTracingController.drawAllCurves.call(selfTracingController)})}}
referenceLandmarks(){const selectedIndex=document.getElementById("pointsId").selectedIndex;const currentPoint=document.getElementById("pointsId").options[selectedIndex].text;const imagePaths=[];imagePaths["Sela (S)"]="selaTurcica.png";imagePaths["Násio (N)"]="nasio.png";imagePaths["Espinha nasal anterior (ENA)"]="ENA.png";imagePaths["Espinha nasal posterior (ENP)"]="ENP.png";imagePaths["Ponto subespinhal (A)"]="A.png";imagePaths["Ponto pupramental (B)"]="B.png";imagePaths["Pogônio (Pog)"]="pogonio.png";imagePaths["Gnátio (Gn)"]="Gnatio.png";imagePaths["Mento (Me)"]="mento.png";imagePaths["Condílio (Co)"]="condilio.png";imagePaths["Pró-nasal (Pn)"]="proNasal.png";imagePaths["Pogônio Mole (Pg)"]="pogonioMole.png";imagePaths["Palato Mole (pm)"]="palatoMole.png";imagePaths["Gônio (Go)"]="";imagePaths["Órbitário (Or)"]="";imagePaths["Pório (Po)"]="";imagePaths["Ponta do Nariz (PtN)"]="";imagePaths["Fossa Ptérigo Maxilar (Fpm)"]="";imagePaths["Pterigóide (Pt)"]="";if(currentPoint!=="Selecione"&&imagePaths[currentPoint]){let img=new Image();let context=document.getElementById("referenceLandmark");if(context.getContext){context=context.getContext("2d");img.onload=function(){context.canvas.width=this.width;context.canvas.height=this.height;document.getElementById("canvas-reference").setAttribute("style","height: "+context.canvas.height+"px"+"width: "+context.canvas.width+"px");context.drawImage(img,0,0,context.canvas.width,context.canvas.height);context.fillStyle="rgba(1, 1, 1, 0)"}}
img.src=this.urls.reference_images+imagePaths[currentPoint]}}
markLandmarkPoint(event){const selectedIndex=document.getElementById("pointsId").selectedIndex;const currentPoint=document.getElementById("pointsId").options[selectedIndex].text;if(currentPoint!=="Selecione"){const landmarkCanvas=this.canvasOdontoradiosis.getCanvas("landmarks");const currentLandmark=this.landmarksController.verifyLandmark(currentPoint,!0);const currentMousePosition=this.scaleManager.getMousePos(landmarkCanvas,event);currentLandmark.X=currentMousePosition.x;currentLandmark.Y=currentMousePosition.y;this.landmarksController.saveLandmarks();this.landmarksController.redrawLandmarks()}}
manageMouseMove(event){event.preventDefault();event.stopPropagation();const canvas=document.getElementById("bezier");let context=canvas.getContext("2d");context.translate(canvas.width/2,canvas.height/2);if(this.infoKeeper.isMouseDown&&this.infoKeeper.isCurveFunction){this.canvasOdontoradiosis.getCanvas("bezier").style.cursor="move";const curveSelectObj=document.getElementById("curvesId");const selectedIndex=curveSelectObj.selectedIndex;const curveName=UsefulMethods.normalizeTracingName(curveSelectObj.options[selectedIndex].text);const referenceCanvas=this.canvasOdontoradiosis.getCanvas("landmarks");const referenceContext=referenceCanvas.getContext("2d");const refrenceRect=referenceCanvas.getBoundingClientRect();if(this.infoKeeper.mousePosition.x==null){this.infoKeeper.mousePosition.x=this.scaleManager.dynamicCanvasScale(event.clientX,!0,referenceContext,refrenceRect);this.infoKeeper.mousePosition.y=this.scaleManager.dynamicCanvasScale(event.clientY,!1,referenceContext,refrenceRect)}else{let currentPosition={x:this.scaleManager.dynamicCanvasScale(event.clientX,!0,referenceContext,refrenceRect),y:this.scaleManager.dynamicCanvasScale(event.clientY,!1,referenceContext,refrenceRect)};const boxVertexInfo=this.infoKeeper.isOnBoxVertex;if(boxVertexInfo.isOn){let scaleX=currentPosition.x/this.infoKeeper.mousePosition.x;if(boxVertexInfo.index<2){scaleX=this.infoKeeper.mousePosition.x/currentPosition.x}
let scaleY=currentPosition.y/this.infoKeeper.mousePosition.y;if(boxVertexInfo.index%2===0){scaleY=this.infoKeeper.mousePosition.y/currentPosition.y}
this.tracingController.rescaleBezier(curveName,scaleX,scaleY)}else if(this.infoKeeper.isOnCurvePoints!=null){this.infoKeeper.isOnCurvePoints[0][this.infoKeeper.isOnCurvePoints[1]]-=this.infoKeeper.mousePosition.x-currentPosition.x;this.infoKeeper.isOnCurvePoints[0][this.infoKeeper.isOnCurvePoints[2]]-=this.infoKeeper.mousePosition.y-currentPosition.y}else if(this.infoKeeper.isInsideBox){this.tracingController.translateBezier(curveName,this.infoKeeper.mousePosition.x-currentPosition.x,this.infoKeeper.mousePosition.y-currentPosition.y)}else{let angle=UsefulMethods.calculateAngle(currentPosition,this.infoKeeper.mousePosition);if(!isNaN(angle)){angle*=UsefulMethods.highLowAngle(this.infoKeeper.mousePosition,{x:currentPosition.x,y:currentPosition.y});this.tracingController.rotateBezier(curveName,angle)}}
this.infoKeeper.mousePosition.x=currentPosition.x;this.infoKeeper.mousePosition.y=currentPosition.y;this.tracingController.drawAllCurves();this.tracingController.drawCurveBox(curveName,!0);this.tracingController.drawPointCircle(curveName);this.tracingController.saveBezierCurve()}}else if(this.infoKeeper.isCurveFunction){this.canvasOdontoradiosis.getCanvas("bezier").style.cursor="crosshair"}}
manageMouseDown(event){const selectedIndex=document.getElementById("curvesId").selectedIndex;const currentCurve=document.getElementById("curvesId").options[selectedIndex].text;const curveName=UsefulMethods.normalizeTracingName(currentCurve);if(currentCurve==="Selecione"){this.infoKeeper.isCurveFunction=!1;this.markLandmarkPoint(event)}else if(this.tracingController.curveExists(curveName)){this.infoKeeper.isCurveFunction=!0;let points=this.tracingController.getBoxDimensions(curveName);const relativeMouse=this.scaleManager.getMousePos(this.canvasOdontoradiosis.getCanvas("bezier"),event);this.infoKeeper.isInsideBox=relativeMouse.x>=points[0]&&relativeMouse.x<=points[0]+points[2]&&relativeMouse.y>=points[1]&&relativeMouse.y<=points[1]+points[3];this.infoKeeper.isOnBoxVertex=this.tracingController.verifyMouseOnBoxVertex(relativeMouse,curveName);this.infoKeeper.isOnCurvePoints=this.tracingController.verifyMouseOnCurvePoint(relativeMouse,curveName)}}
facial_analysis(){if(enable_draw_bezier){const glabela={x:all_curves["perfil-mole"][0][0],y:all_curves["perfil-mole"][0][1]};const subnasal={x:all_curves["perfil-mole"][1][4],y:all_curves["perfil-mole"][1][5]};const pogonion={x:all_curves["perfil-mole"][5][4],y:all_curves["perfil-mole"][5][5]};const div=document.getElementById("bezier");let ctx=div.getContext("2d");ctx.strokeStyle="#451c87";ctx.beginPath();ctx.moveTo(pogonion.x,pogonion.y);ctx.lineTo(subnasal.x,subnasal.y);ctx.lineTo(glabela.x,glabela.y);ctx.lineWidth=lineWidth*2;ctx.stroke();let toCalculate=normalizeValues(glabela,pogonion,subnasal);let angle=calculateAngle(toCalculate[0],toCalculate[1])*(subnasal.x>pogonion.x?-1:1);angle=(180*angle)/Math.PI;let td=document.getElementById("td-face_type");if(angle+5>=0&&angle+5<=10){td.innerHTML="Reto"}else if(angle<0){td.innerHTML="Concavo"}else{td.innerHTML="Convexo"}}}};class EventsOdontoradiosis{constructor(mainController,infoKeeper,imageEffects){this.mainController=mainController;this.infoKeeper=infoKeeper;this.imageEffects=imageEffects;document.getElementById("stack-canvas").onmousedown=function(event){mainController.manageMouseDown.call(mainController,event)};document.getElementById("stack-canvas").onmousemove=function(event){mainController.manageMouseMove.call(mainController,event)};const tracingController=this.mainController.tracingController;document.getElementById("pointsId").onchange=function(){if(document.getElementById("curvesId").selectedIndex!=0){document.getElementById("curvesId").selectedIndex=0;tracingController.drawAllCurves();mainController.canvasOdontoradiosis.stackCanvas.style.cursor="crosshair"}
mainController.referenceLandmarks.call(mainController)}}
addEffectsEvent(){let elements=["contrast","brightness","invert","grayscale"];const selfImageEffects=this.imageEffects;for(let i=0;i<elements.length;i++){document.getElementById(elements[i]).addEventListener("input",function(){selfImageEffects.onChangeValue.call(selfImageEffects)})}
document.getElementById("undone-effects").onclick=function(){selfImageEffects.reset.call(selfImageEffects)}}
addCanvasInputEvents(){let curveSelect=document.getElementById("curvesId");const tracingController=this.mainController.tracingController;const stackCanvas=this.mainController.canvasOdontoradiosis.stackCanvas;curveSelect.addEventListener("input",function(){const selectedIndex=document.getElementById("curvesId").selectedIndex;let currentSelection=document.getElementById("curvesId").options[selectedIndex].text;tracingController.drawAllCurves();if(currentSelection!=="Selecione"){const currentCurve=UsefulMethods.normalizeTracingName(currentSelection);if(tracingController.curveExists(currentCurve)){tracingController.drawCurveBox.call(tracingController,currentCurve,!0);tracingController.drawPointCircle.call(tracingController,currentCurve);stackCanvas.style.cursor="move"}}else{stackCanvas.style.cursor="crosshair"}})}
generateMouseEvents(){const currentObject=this;const odontoradiosisKeeper=this.infoKeeper;document.onmousedown=function(){let hiddenForm=document.getElementById("current_image");const splicedSource=currentObject.mainController.getUrl("image").split("/");hiddenForm.setAttribute("value",splicedSource[splicedSource.length-2]+"/"+splicedSource[splicedSource.length-1]);odontoradiosisKeeper.isMouseDown=!0};document.onmouseup=function(){odontoradiosisKeeper.isMouseDown=!1;odontoradiosisKeeper.isInsideBox=!1;odontoradiosisKeeper.isOnBoxVertex={isOn:!1,index:0};odontoradiosisKeeper.isOnCurvePoints=null;odontoradiosisKeeper.mousePosition.x=null;odontoradiosisKeeper.mousePosition.y=null}}
applyAllEvents(){this.addEffectsEvent();this.addCanvasInputEvents();this.generateMouseEvents()}};const scaleManager=new ScaleManager();const canvasOdontoradiosis=new CanvasOdontoradiosis(document.getElementById("stack-canvas"),scaleManager,{image:0,bezier:1,landmarks:2});const imageEffects=new ImageEffects(canvasOdontoradiosis);const infoKeeper=new OdontoradiosisKeeper();const mainController=new MainController({image:"",curves:curves_url,landmarks:landmarks_url,reference_images:reference_images_url},canvasOdontoradiosis,scaleManager,infoKeeper);const eventsController=new EventsOdontoradiosis(mainController,infoKeeper,imageEffects);function openImage(path="",id=-1){mainController.tracingController.setBezierPoints([]);mainController.setUrl("image",path);canvasOdontoradiosis.openImage(path,function(){mainController.loadJsonCurve(id);mainController.loadJsonLandmarks(id)},id);imageEffects.reset()}
window.onload=function(){eventsController.applyAllEvents()}