import { Component, ViewChild } from '@angular/core';
import OdontoradiosisKeeper from '../../domain/models/odontoradiosisKeeper';
import ScaleManager from '../../domain/util/scaleManager';
import UsefulMethods from '../../domain/util/usefulMethods';
import * as i0 from "@angular/core";
import * as i1 from "../../cephalometric-canvas.service";
export class CephalometricCanvasComponent {
    constructor(canvasService, infoKeeper, scaleManager) {
        this.canvasService = canvasService;
        this.infoKeeper = infoKeeper;
        this.scaleManager = scaleManager;
    }
    ngOnInit() { }
    ngAfterViewInit() {
        this.canvasService.init(this.stackCanvasElement.nativeElement);
        this.canvasService.cephalometricCanvas.addCanvasElement('image', this.canvasImageElement.nativeElement);
        this.canvasService.cephalometricCanvas.addCanvasElement('bezier', this.canvasBezierElement.nativeElement);
        this.canvasService.cephalometricCanvas.addCanvasElement('landmarks', this.canvasLandmarksElement.nativeElement);
    }
    onMouseMove(event) {
        event.preventDefault();
        event.stopPropagation(); // tell the browser we're handling this event
        const canvasController = this.canvasService.cephalometricCanvas;
        const tracingController = this.canvasService.tracingController;
        const bezierCanvas = canvasController.getCanvas('bezier');
        const context = canvasController.getContext('bezier');
        context.translate(bezierCanvas.width / 2, bezierCanvas.height / 2);
        if (this.infoKeeper.isMouseDown && this.infoKeeper.isCurveFunction) {
            /* do drag things */
            canvasController.canvasCursor = 'move';
            const curveName = UsefulMethods.normalizeTracingName(this.infoKeeper.selectedOptions.curve);
            const referenceCanvas = canvasController.getCanvas('landmarks');
            const referenceContext = canvasController.getContext('landmarks');
            const referenceRect = referenceCanvas.getBoundingClientRect();
            const currentPosition = {
                x: this.scaleManager.dynamicCanvasScale(event.clientX, true, referenceContext, referenceRect),
                y: this.scaleManager.dynamicCanvasScale(event.clientY, false, referenceContext, referenceRect),
            };
            if (this.infoKeeper.mousePosition.disabled) {
                this.infoKeeper.mousePosition.x = currentPosition.x;
                this.infoKeeper.mousePosition.y = currentPosition.y;
                this.infoKeeper.mousePosition.disabled = false;
            }
            else {
                const boxVertexInfo = this.infoKeeper.isOnBoxVertex;
                if (boxVertexInfo.isOn) {
                    /*still need to fix problem when rescale with top points*/
                    let scaleX = currentPosition.x / this.infoKeeper.mousePosition.x;
                    if (boxVertexInfo.index < 2) {
                        scaleX =
                            this.infoKeeper.mousePosition.x / currentPosition.x;
                    }
                    let scaleY = currentPosition.y / this.infoKeeper.mousePosition.y;
                    if (boxVertexInfo.index % 2 === 0) {
                        scaleY =
                            this.infoKeeper.mousePosition.y / currentPosition.y;
                    }
                    tracingController.rescaleBezier(curveName, scaleX, scaleY);
                }
                else if (this.infoKeeper.isOnCurvePoints != null) {
                    const curvePoints = this.infoKeeper
                        .isOnCurvePoints[0];
                    curvePoints[this.infoKeeper.isOnCurvePoints[1]] -=
                        this.infoKeeper.mousePosition.x - currentPosition.x;
                    curvePoints[this.infoKeeper.isOnCurvePoints[2]] -=
                        this.infoKeeper.mousePosition.y - currentPosition.y;
                }
                else if (this.infoKeeper.isInsideBox) {
                    tracingController.translateBezier(curveName, this.infoKeeper.mousePosition.x - currentPosition.x, this.infoKeeper.mousePosition.y - currentPosition.y);
                }
                else {
                    let angle = UsefulMethods.calculateAngle(currentPosition, this.infoKeeper.mousePosition);
                    if (!isNaN(angle)) {
                        angle *= UsefulMethods.highLowAngle(this.infoKeeper.mousePosition, {
                            x: currentPosition.x,
                            y: currentPosition.y,
                        });
                        tracingController.rotateBezier(curveName, angle);
                    }
                }
                this.infoKeeper.mousePosition.x = currentPosition.x;
                this.infoKeeper.mousePosition.y = currentPosition.y;
                this.infoKeeper.mousePosition.disabled = false;
                tracingController.drawAllCurves();
                tracingController.drawCurveBox(curveName, true);
                tracingController.drawPointCircle(curveName);
                tracingController.saveBezierCurve();
            }
        }
        else if (this.infoKeeper.isCurveFunction) {
            canvasController.canvasCursor = 'crosshair';
        }
    }
    /**
     * Receive a event and manage when to select curve or landmark functions
     * @param event
     */
    onMouseDown(event) {
        this.infoKeeper.isMouseDown = true;
        // Start handling the mouse position
        const currentCurve = this.infoKeeper.selectedOptions.curve;
        const curveName = UsefulMethods.normalizeTracingName(currentCurve);
        const tracingController = this.canvasService.tracingController;
        const canvasOdontoradiosis = this.canvasService.cephalometricCanvas;
        if (currentCurve.length <= 0 || currentCurve === 'Selecione') {
            this.infoKeeper.isCurveFunction = false;
            const landmarkName = this.infoKeeper.selectedOptions.landmark;
            this.canvasService.controller.markLandmarkPoint(landmarkName, {
                x: event.clientX,
                y: event.clientY,
            });
        }
        else if (tracingController.curveExists(curveName)) {
            this.infoKeeper.isCurveFunction = true;
            const points = tracingController.getBoxDimensions(curveName);
            const relativeMouse = this.scaleManager.getMousePos(canvasOdontoradiosis.getCanvas('bezier'), { x: event.clientX, y: event.clientY });
            this.infoKeeper.isInsideBox =
                relativeMouse.x >= points[0] &&
                    relativeMouse.x <= points[0] + points[2] &&
                    relativeMouse.y >= points[1] &&
                    relativeMouse.y <= points[1] + points[3];
            this.infoKeeper.isOnBoxVertex =
                tracingController.verifyMouseOnBoxVertex(relativeMouse, curveName);
            this.infoKeeper.isOnCurvePoints =
                tracingController.verifyMouseOnCurvePoint(relativeMouse, curveName);
        }
    }
    onMouseUp() {
        this.infoKeeper.isMouseDown = false;
        this.infoKeeper.isInsideBox = false;
        this.infoKeeper.isOnBoxVertex = { isOn: false, index: 0 };
        this.infoKeeper.isOnCurvePoints = null;
        /*this.infoKeeper.mousePosition.x = null;
        this.infoKeeper.mousePosition.y = null;*/
        this.infoKeeper.mousePosition.disabled = true;
    }
}
CephalometricCanvasComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.0", ngImport: i0, type: CephalometricCanvasComponent, deps: [{ token: i1.CephalometricCanvasService }, { token: OdontoradiosisKeeper }, { token: ScaleManager }], target: i0.ɵɵFactoryTarget.Component });
CephalometricCanvasComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.0.0", type: CephalometricCanvasComponent, selector: "lib-cephalometric-canvas", viewQueries: [{ propertyName: "stackCanvasElement", first: true, predicate: ["stackCanvas"], descendants: true }, { propertyName: "canvasImageElement", first: true, predicate: ["canvasImage"], descendants: true }, { propertyName: "canvasBezierElement", first: true, predicate: ["canvasBezier"], descendants: true }, { propertyName: "canvasLandmarksElement", first: true, predicate: ["canvasLandmarks"], descendants: true }], ngImport: i0, template: "<div id=\"card-canvas\" class=\"card-body\">\r\n  <div\r\n    (pointerdown)=\"onMouseDown($event)\"\r\n    (pointerup)=\"onMouseUp()\"\r\n    (pointermove)=\"onMouseMove($event)\"\r\n    #stackCanvas\r\n    id=\"stack-canvas\"\r\n  >\r\n    <canvas #canvasImage id=\"image\"> </canvas>\r\n    <canvas #canvasBezier id=\"bezier\"> </canvas>\r\n    <canvas #canvasLandmarks id=\"landmarks\"> </canvas>\r\n  </div>\r\n</div>\r\n", styles: ["#stack-canvas{position:relative;cursor:crosshair}#stack-canvas>canvas{max-width:100%;height:auto;position:absolute;left:0;top:0}#stack-canvas>canvas .image{z-index:0}#stack-canvas>canvas .bezier{z-index:1}#stack-canvas>canvas .landmarks{z-index:2}.card-body{max-width:100%;min-height:20rem;min-width:20rem}\n"] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.0", ngImport: i0, type: CephalometricCanvasComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-cephalometric-canvas', template: "<div id=\"card-canvas\" class=\"card-body\">\r\n  <div\r\n    (pointerdown)=\"onMouseDown($event)\"\r\n    (pointerup)=\"onMouseUp()\"\r\n    (pointermove)=\"onMouseMove($event)\"\r\n    #stackCanvas\r\n    id=\"stack-canvas\"\r\n  >\r\n    <canvas #canvasImage id=\"image\"> </canvas>\r\n    <canvas #canvasBezier id=\"bezier\"> </canvas>\r\n    <canvas #canvasLandmarks id=\"landmarks\"> </canvas>\r\n  </div>\r\n</div>\r\n", styles: ["#stack-canvas{position:relative;cursor:crosshair}#stack-canvas>canvas{max-width:100%;height:auto;position:absolute;left:0;top:0}#stack-canvas>canvas .image{z-index:0}#stack-canvas>canvas .bezier{z-index:1}#stack-canvas>canvas .landmarks{z-index:2}.card-body{max-width:100%;min-height:20rem;min-width:20rem}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.CephalometricCanvasService }, { type: OdontoradiosisKeeper }, { type: ScaleManager }]; }, propDecorators: { stackCanvasElement: [{
                type: ViewChild,
                args: ['stackCanvas']
            }], canvasImageElement: [{
                type: ViewChild,
                args: ['canvasImage']
            }], canvasBezierElement: [{
                type: ViewChild,
                args: ['canvasBezier']
            }], canvasLandmarksElement: [{
                type: ViewChild,
                args: ['canvasLandmarks']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VwaGFsb21ldHJpYy1jYW52YXMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY2VwaGFsb21ldHJpYy1jYW52YXMvc3JjL2xpYi9jb21wb25lbnRzL2NlcGhhbG9tZXRyaWMtY2FudmFzL2NlcGhhbG9tZXRyaWMtY2FudmFzLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NlcGhhbG9tZXRyaWMtY2FudmFzL3NyYy9saWIvY29tcG9uZW50cy9jZXBoYWxvbWV0cmljLWNhbnZhcy9jZXBoYWxvbWV0cmljLWNhbnZhcy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFzQixTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFekUsT0FBTyxvQkFBb0IsTUFBTSwwQ0FBMEMsQ0FBQztBQUU1RSxPQUFPLFlBQVksTUFBTSxnQ0FBZ0MsQ0FBQztBQUMxRCxPQUFPLGFBQWEsTUFBTSxpQ0FBaUMsQ0FBQzs7O0FBTzVELE1BQU0sT0FBTyw0QkFBNEI7SUFhckMsWUFDWSxhQUF5QyxFQUN6QyxVQUFnQyxFQUNoQyxZQUEwQjtRQUYxQixrQkFBYSxHQUFiLGFBQWEsQ0FBNEI7UUFDekMsZUFBVSxHQUFWLFVBQVUsQ0FBc0I7UUFDaEMsaUJBQVksR0FBWixZQUFZLENBQWM7SUFDbkMsQ0FBQztJQUVKLFFBQVEsS0FBVSxDQUFDO0lBRW5CLGVBQWU7UUFDWCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FDbkQsT0FBTyxFQUNQLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQ3hDLENBQUM7UUFDRixJQUFJLENBQUMsYUFBYSxDQUFDLG1CQUFt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bUI7c0JBRGxCLFNBQVM7dUJBQUMsY0FBYztnQkFJekIsc0JBQXNCO3NCQURyQixTQUFTO3VCQUFDLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgT25Jbml0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ2VwaGFsb21ldHJpY0NhbnZhc1NlcnZpY2UgfSBmcm9tICcuLi8uLi9jZXBoYWxvbWV0cmljLWNhbnZhcy5zZXJ2aWNlJztcclxuaW1wb3J0IE9kb250b3JhZGlvc2lzS2VlcGVyIGZyb20gJy4uLy4uL2RvbWFpbi9tb2RlbHMvb2RvbnRvcmFkaW9zaXNLZWVwZXInO1xyXG5pbXBvcnQgeyBJUG9pbnRCaWRpbWVuc2lvbmFsIH0gZnJvbSAnLi4vLi4vZG9tYWluL3V0aWwvaW50ZXJmYWNlcy9pbnRlcmZhY2VzJztcclxuaW1wb3J0IFNjYWxlTWFuYWdlciBmcm9tICcuLi8uLi9kb21haW4vdXRpbC9zY2FsZU1hbmFnZXInO1xyXG5pbXBvcnQgVXNlZnVsTWV0aG9kcyBmcm9tICcuLi8uLi9kb21haW4vdXRpbC91c2VmdWxNZXRob2RzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdsaWItY2VwaGFsb21ldHJpYy1jYW52YXMnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NlcGhhbG9tZXRyaWMtY2FudmFzLmNvbXBvbmVudC5odG1sJyxcclxuICAgIHN0eWxlVXJsczogWycuL2NlcGhhbG9tZXRyaWMtY2FudmFzLmNvbXBvbmVudC5zY3NzJ10sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBDZXBoYWxvbWV0cmljQ2FudmFzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICAgIEBWaWV3Q2hpbGQoJ3N0YWNrQ2FudmFzJylcclxuICAgIHN0YWNrQ2FudmFzRWxlbWVudCE6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xyXG5cclxuICAgIEBWaWV3Q2hpbGQoJ2NhbnZhc0ltYWdlJylcclxuICAgIGNhbnZhc0ltYWdlRWxlbWVudCE6IEVsZW1lbnRSZWY8SFRNTENhbnZhc0VsZW1lbnQ+O1xyXG5cclxuICAgIEBWaWV3Q2hpbGQoJ2NhbnZhc0JlemllcicpXHJcbiAgICBjYW52YXNCZXppZXJFbGVtZW50ITogRWxlbWVudFJlZjxIVE1MQ2FudmFzRWxlbWVudD47XHJcblxyXG4gICAgQFZpZXdDaGlsZCgnY2FudmFzTGFuZG1hcmtzJylcclxuICAgIGNhbnZhc0xhbmRtYXJrc0VsZW1lbnQhOiBFbGVtZW50UmVmPEhUTUxDYW52YXNFbGVtZW50PjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIGNhbnZhc1NlcnZpY2U6IENlcGhhbG9tZXRyaWNDYW52YXNTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgaW5mb0tlZXBlcjogT2RvbnRvcmFkaW9zaXNLZWVwZXIsXHJcbiAgICAgICAgcHJpdmF0ZSBzY2FsZU1hbmFnZXI6IFNjYWxlTWFuYWdlclxyXG4gICAgKSB7fVxyXG5cclxuICAgIG5nT25Jbml0KCk6IHZvaWQge31cclxuXHJcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jYW52YXNTZXJ2aWNlLmluaXQodGhpcy5zdGFja0NhbnZhc0VsZW1lbnQubmF0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXNTZXJ2aWNlLmNlcGhhbG9tZXRyaWNDYW52YXMuYWRkQ2FudmFzRWxlbWVudChcclxuICAgICAgICAgICAgJ2ltYWdlJyxcclxuICAgICAgICAgICAgdGhpcy5jYW52YXNJbWFnZUVsZW1lbnQubmF0aXZlRWxlbWVudFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5jYW52YXNTZXJ2aWNlLmNlcGhhbG9tZXRyaWNDYW52YXMuYWRkQ2FudmFzRWxlbWVudChcclxuICAgICAgICAgICAgJ2JlemllcicsXHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzQmV6aWVyRWxlbWVudC5uYXRpdmVFbGVtZW50XHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLmNhbnZhc1NlcnZpY2UuY2VwaGFsb21ldHJpY0NhbnZhcy5hZGRDYW52YXNFbGVtZW50KFxyXG4gICAgICAgICAgICAnbGFuZG1hcmtzJyxcclxuICAgICAgICAgICAgdGhpcy5jYW52YXNMYW5kbWFya3NFbGVtZW50Lm5hdGl2ZUVsZW1lbnRcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIG9uTW91c2VNb3ZlKGV2ZW50OiBQb2ludGVyRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyB0ZWxsIHRoZSBicm93c2VyIHdlJ3JlIGhhbmRsaW5nIHRoaXMgZXZlbnRcclxuXHJcbiAgICAgICAgY29uc3QgY2FudmFzQ29udHJvbGxlciA9IHRoaXMuY2FudmFzU2VydmljZS5jZXBoYWxvbWV0cmljQ2FudmFzO1xyXG4gICAgICAgIGNvbnN0IHRyYWNpbmdDb250cm9sbGVyID0gdGhpcy5jYW52YXNTZXJ2aWNlLnRyYWNpbmdDb250cm9sbGVyO1xyXG5cclxuICAgICAgICBjb25zdCBiZXppZXJDYW52YXMgPSBjYW52YXNDb250cm9sbGVyLmdldENhbnZhcygnYmV6aWVyJyk7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhc0NvbnRyb2xsZXIuZ2V0Q29udGV4dCgnYmV6aWVyJyk7XHJcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoYmV6aWVyQ2FudmFzLndpZHRoIC8gMiwgYmV6aWVyQ2FudmFzLmhlaWdodCAvIDIpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pbmZvS2VlcGVyLmlzTW91c2VEb3duICYmIHRoaXMuaW5mb0tlZXBlci5pc0N1cnZlRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgLyogZG8gZHJhZyB0aGluZ3MgKi9cclxuICAgICAgICAgICAgY2FudmFzQ29udHJvbGxlci5jYW52YXNDdXJzb3IgPSAnbW92ZSc7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjdXJ2ZU5hbWUgPSBVc2VmdWxNZXRob2RzLm5vcm1hbGl6ZVRyYWNpbmdOYW1lKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvS2VlcGVyLnNlbGVjdGVkT3B0aW9ucy5jdXJ2ZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2VDYW52YXMgPSBjYW52YXNDb250cm9sbGVyLmdldENhbnZhcygnbGFuZG1hcmtzJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZUNvbnRleHQgPSBjYW52YXNDb250cm9sbGVyLmdldENvbnRleHQoJ2xhbmRtYXJrcycpO1xyXG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2VSZWN0ID0gcmVmZXJlbmNlQ2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFBvc2l0aW9uOiBJUG9pbnRCaWRpbWVuc2lvbmFsID0ge1xyXG4gICAgICAgICAgICAgICAgeDogdGhpcy5zY2FsZU1hbmFnZXIuZHluYW1pY0NhbnZhc1NjYWxlKFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmNsaWVudFgsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VDb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZVJlY3RcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnNjYWxlTWFuYWdlci5keW5hbWljQ2FudmFzU2NhbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2xpZW50WSxcclxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VDb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZVJlY3RcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvS2VlcGVyLm1vdXNlUG9zaXRpb24uZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0tlZXBlci5tb3VzZVBvc2l0aW9uLnggPSBjdXJyZW50UG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0tlZXBlci5tb3VzZVBvc2l0aW9uLnkgPSBjdXJyZW50UG9zaXRpb24ueTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0tlZXBlci5tb3VzZVBvc2l0aW9uLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3hWZXJ0ZXhJbmZvID0gdGhpcy5pbmZvS2VlcGVyLmlzT25Cb3hWZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm94VmVydGV4SW5mby5pc09uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLypzdGlsbCBuZWVkIHRvIGZpeCBwcm9ibGVtIHdoZW4gcmVzY2FsZSB3aXRoIHRvcCBwb2ludHMqL1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FsZVggPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24ueCAvIHRoaXMuaW5mb0tlZXBlci5tb3VzZVBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJveFZlcnRleEluZm8uaW5kZXggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm9LZWVwZXIubW91c2VQb3NpdGlvbi54IC8gY3VycmVudFBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FsZVkgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24ueSAvIHRoaXMuaW5mb0tlZXBlci5tb3VzZVBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJveFZlcnRleEluZm8uaW5kZXggJSAyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm9LZWVwZXIubW91c2VQb3NpdGlvbi55IC8gY3VycmVudFBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNpbmdDb250cm9sbGVyLnJlc2NhbGVCZXppZXIoY3VydmVOYW1lLCBzY2FsZVgsIHNjYWxlWSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW5mb0tlZXBlci5pc09uQ3VydmVQb2ludHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnZlUG9pbnRzID0gdGhpcy5pbmZvS2VlcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pc09uQ3VydmVQb2ludHNbMF0gYXMgbnVtYmVyW107XHJcbiAgICAgICAgICAgICAgICAgICAgY3VydmVQb2ludHNbdGhpcy5pbmZvS2VlcGVyLmlzT25DdXJ2ZVBvaW50c1sxXSBhcyBudW1iZXJdIC09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mb0tlZXBlci5tb3VzZVBvc2l0aW9uLnggLSBjdXJyZW50UG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZVBvaW50c1t0aGlzLmluZm9LZWVwZXIuaXNPbkN1cnZlUG9pbnRzWzJdIGFzIG51bWJlcl0gLT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvS2VlcGVyLm1vdXNlUG9zaXRpb24ueSAtIGN1cnJlbnRQb3NpdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmluZm9LZWVwZXIuaXNJbnNpZGVCb3gpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFjaW5nQ29udHJvbGxlci50cmFuc2xhdGVCZXppZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZvS2VlcGVyLm1vdXNlUG9zaXRpb24ueCAtIGN1cnJlbnRQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm9LZWVwZXIubW91c2VQb3NpdGlvbi55IC0gY3VycmVudFBvc2l0aW9uLnlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYW5nbGUgPSBVc2VmdWxNZXRob2RzLmNhbGN1bGF0ZUFuZ2xlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mb0tlZXBlci5tb3VzZVBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGFuZ2xlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZSAqPSBVc2VmdWxNZXRob2RzLmhpZ2hMb3dBbmdsZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mb0tlZXBlci5tb3VzZVBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGN1cnJlbnRQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN1cnJlbnRQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjaW5nQ29udHJvbGxlci5yb3RhdGVCZXppZXIoY3VydmVOYW1lLCBhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvS2VlcGVyLm1vdXNlUG9zaXRpb24ueCA9IGN1cnJlbnRQb3NpdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvS2VlcGVyLm1vdXNlUG9zaXRpb24ueSA9IGN1cnJlbnRQb3NpdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvS2VlcGVyLm1vdXNlUG9zaXRpb24uZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRyYWNpbmdDb250cm9sbGVyLmRyYXdBbGxDdXJ2ZXMoKTtcclxuICAgICAgICAgICAgICAgIHRyYWNpbmdDb250cm9sbGVyLmRyYXdDdXJ2ZUJveChjdXJ2ZU5hbWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2luZ0NvbnRyb2xsZXIuZHJhd1BvaW50Q2lyY2xlKGN1cnZlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0cmFjaW5nQ29udHJvbGxlci5zYXZlQmV6aWVyQ3VydmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbmZvS2VlcGVyLmlzQ3VydmVGdW5jdGlvbikge1xyXG4gICAgICAgICAgICBjYW52YXNDb250cm9sbGVyLmNhbnZhc0N1cnNvciA9ICdjcm9zc2hhaXInO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY2VpdmUgYSBldmVudCBhbmQgbWFuYWdlIHdoZW4gdG8gc2VsZWN0IGN1cnZlIG9yIGxhbmRtYXJrIGZ1bmN0aW9uc1xyXG4gICAgICogQHBhcmFtIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIG9uTW91c2VEb3duKGV2ZW50OiBQb2ludGVyRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmluZm9LZWVwZXIuaXNNb3VzZURvd24gPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBTdGFydCBoYW5kbGluZyB0aGUgbW91c2UgcG9zaXRpb25cclxuICAgICAgICBjb25zdCBjdXJyZW50Q3VydmUgPSB0aGlzLmluZm9LZWVwZXIuc2VsZWN0ZWRPcHRpb25zLmN1cnZlO1xyXG4gICAgICAgIGNvbnN0IGN1cnZlTmFtZSA9IFVzZWZ1bE1ldGhvZHMubm9ybWFsaXplVHJhY2luZ05hbWUoY3VycmVudEN1cnZlKTtcclxuICAgICAgICBjb25zdCB0cmFjaW5nQ29udHJvbGxlciA9IHRoaXMuY2FudmFzU2VydmljZS50cmFjaW5nQ29udHJvbGxlcjtcclxuICAgICAgICBjb25zdCBjYW52YXNPZG9udG9yYWRpb3NpcyA9IHRoaXMuY2FudmFzU2VydmljZS5jZXBoYWxvbWV0cmljQ2FudmFzO1xyXG4gICAgICAgIGlmIChjdXJyZW50Q3VydmUubGVuZ3RoIDw9IDAgfHwgY3VycmVudEN1cnZlID09PSAnU2VsZWNpb25lJykge1xyXG4gICAgICAgICAgICB0aGlzLmluZm9LZWVwZXIuaXNDdXJ2ZUZ1bmN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhbmRtYXJrTmFtZSA9IHRoaXMuaW5mb0tlZXBlci5zZWxlY3RlZE9wdGlvbnMubGFuZG1hcms7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzU2VydmljZS5jb250cm9sbGVyLm1hcmtMYW5kbWFya1BvaW50KGxhbmRtYXJrTmFtZSwge1xyXG4gICAgICAgICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2luZ0NvbnRyb2xsZXIuY3VydmVFeGlzdHMoY3VydmVOYW1lKSkge1xyXG4gICAgICAgICAgICB0aGlzLmluZm9LZWVwZXIuaXNDdXJ2ZUZ1bmN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gdHJhY2luZ0NvbnRyb2xsZXIuZ2V0Qm94RGltZW5zaW9ucyhjdXJ2ZU5hbWUpO1xyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZU1vdXNlID0gdGhpcy5zY2FsZU1hbmFnZXIuZ2V0TW91c2VQb3MoXHJcbiAgICAgICAgICAgICAgICBjYW52YXNPZG9udG9yYWRpb3Npcy5nZXRDYW52YXMoJ2JlemllcicpLFxyXG4gICAgICAgICAgICAgICAgeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5pbmZvS2VlcGVyLmlzSW5zaWRlQm94ID1cclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlTW91c2UueCA+PSBwb2ludHNbMF0gJiZcclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlTW91c2UueCA8PSBwb2ludHNbMF0gKyBwb2ludHNbMl0gJiZcclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlTW91c2UueSA+PSBwb2ludHNbMV0gJiZcclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlTW91c2UueSA8PSBwb2ludHNbMV0gKyBwb2ludHNbM107XHJcbiAgICAgICAgICAgIHRoaXMuaW5mb0tlZXBlci5pc09uQm94VmVydGV4ID1cclxuICAgICAgICAgICAgICAgIHRyYWNpbmdDb250cm9sbGVyLnZlcmlmeU1vdXNlT25Cb3hWZXJ0ZXgoXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVNb3VzZSxcclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZU5hbWVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5mb0tlZXBlci5pc09uQ3VydmVQb2ludHMgPVxyXG4gICAgICAgICAgICAgICAgdHJhY2luZ0NvbnRyb2xsZXIudmVyaWZ5TW91c2VPbkN1cnZlUG9pbnQoXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVNb3VzZSxcclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZU5hbWVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uTW91c2VVcCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmluZm9LZWVwZXIuaXNNb3VzZURvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmluZm9LZWVwZXIuaXNJbnNpZGVCb3ggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmluZm9LZWVwZXIuaXNPbkJveFZlcnRleCA9IHsgaXNPbjogZmFsc2UsIGluZGV4OiAwIH07XHJcbiAgICAgICAgdGhpcy5pbmZvS2VlcGVyLmlzT25DdXJ2ZVBvaW50cyA9IG51bGw7XHJcblxyXG4gICAgICAgIC8qdGhpcy5pbmZvS2VlcGVyLm1vdXNlUG9zaXRpb24ueCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmZvS2VlcGVyLm1vdXNlUG9zaXRpb24ueSA9IG51bGw7Ki9cclxuICAgICAgICB0aGlzLmluZm9LZWVwZXIubW91c2VQb3NpdGlvbi5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuIiwiPGRpdiBpZD1cImNhcmQtY2FudmFzXCIgY2xhc3M9XCJjYXJkLWJvZHlcIj5cclxuICA8ZGl2XHJcbiAgICAocG9pbnRlcmRvd24pPVwib25Nb3VzZURvd24oJGV2ZW50KVwiXHJcbiAgICAocG9pbnRlcnVwKT1cIm9uTW91c2VVcCgpXCJcclxuICAgIChwb2ludGVybW92ZSk9XCJvbk1vdXNlTW92ZSgkZXZlbnQpXCJcclxuICAgICNzdGFja0NhbnZhc1xyXG4gICAgaWQ9XCJzdGFjay1jYW52YXNcIlxyXG4gID5cclxuICAgIDxjYW52YXMgI2NhbnZhc0ltYWdlIGlkPVwiaW1hZ2VcIj4gPC9jYW52YXM+XHJcbiAgICA8Y2FudmFzICNjYW52YXNCZXppZXIgaWQ9XCJiZXppZXJcIj4gPC9jYW52YXM+XHJcbiAgICA8Y2FudmFzICNjYW52YXNMYW5kbWFya3MgaWQ9XCJsYW5kbWFya3NcIj4gPC9jYW52YXM+XHJcbiAgPC9kaXY+XHJcbjwvZGl2PlxyXG4iXX0=